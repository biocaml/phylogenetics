(** Lists with at least one element

    This module provides an alternative to the standard [List]
    module, with the guarantee that the list is non-empty.
*)

type 'a t = Cons of 'a * 'a list
[@@deriving sexp]

(** {2 Basic Operations} *)

val hd : 'a t -> 'a
(** [hd l] returns the head element of the non-empty list [l].

    Example usage of the [hd] function:
    {[
      let lst = Cons (1, [2; 3; 4]) in
      let head = hd lst in
      print_endline (string_of_int head) (* Output: 1 *)
    ]}
*)

val length : _ t -> int
(** [length l] returns the number of elements in the non-empty list
    [l].

    Example:
    {[
      let lst = Cons (1, [2; 3; 4]) in
      let len = length lst in
      print_endline (string_of_int len) (* Output: 4 *)
    ]}
*)

val singleton : 'a -> 'a t
(** [singleton x] creates a non-empty list containing a single element
    [x].

    Example:
    {[
      let lst = singleton 42 in
      let head = hd lst in
      print_endline (string_of_int head) (* Output: 42 *)
    ]}
*)

val cons : 'a -> 'a list -> 'a t
(** [cons h t] constructs a non-empty list with the head element [h]
    and a (possibly empty) list [t] as tail.

    Example:
    {[
      let lst = cons 1 [2; 3; 4] in
      let head = hd lst in
      let tail = List1.tl (to_list lst) in
      let _ = print_endline (string_of_int head) in (* Output: 1 *)
      List1.iter (fun x -> print_endline (string_of_int x)) tail (* Output: 2 3 4 *)
    ]}
*)

val cons1 : 'a -> 'a t -> 'a t
(** [cons1 h tl] prepends the head element [h] to the existing
    non-empty list [tl].

    Note: This function is different from {!cons} because it operates
    on an existing non-empty list instead of a tail list.
*)

val init : int -> f:(int -> 'a) -> 'a t
(** [init n ~f] creates a non-empty list of length [n], where each
    element is generated by applying the function [f]. Raises
    [Invalid_argument] if [n] is less than 1.

    Example:
    {[
      let lst = init 5 ~f:(fun x -> x * x) in
      List1.iter (fun x -> print_endline (string_of_int x)) lst (* Output: 0 1 4 9 16 *)
    ]}
*)

val rev : 'a t -> 'a t
(** [rev l] reverses the non-empty list [l].

    Example:
    {[
      let lst = Cons (1, [2; 3; 4]) in
      List1.iter (fun x -> print_endline (string_of_int x)) (rev lst) (* Output: 4 3 2 1 *)
    ]}
*)

val map : 'a t -> f:('a -> 'b) -> 'b t
(** [map l ~f] applies the function [f] to each element of the
    non-empty list [l] and returns a new non-empty list with the
    transformed elements.

    Example:
    {[
      let lst = Cons (1, [2; 3; 4]) in
      let lst' = map lst ~f:(fun x -> x * x) in
      List1.iter (fun x -> print_endline (string_of_int x)) lst' (* Output: 1 4 9 16 *)
    ]}
*)

val mapi : 'a t -> f:(int -> 'a -> 'b) -> 'b t
(** [mapi l ~f] applies the function [f] to each element of the
    non-empty list [l] along with its index and returns a new
    non-empty list with the transformed elements.

    Example:
    {[
      let lst = Cons (1, [2; 3; 4]) in
      let lst' = mapi lst ~f:(fun i x -> i * x) in
      List1.iter (fun x -> print_endline (string_of_int x)) lst' (* Output: 0 2 6 12 *)
    ]}
*)

val map2 : 'a t -> 'b t -> f:('a -> 'b -> 'c) -> ('c t, [> `Unequal_lengths]) result
(** [map2 l1 l2 ~f] applies the function [f] element-wise to the
    elements of the non-empty lists [l1] and [l2], and returns a new
    non-empty list with the results. Returns a result containing
    either a new non-empty list with the results, or an error if the
    lists have unequal lengths.

    Example:
    {[
      let lst1 = Cons (1, [2; 3; 4]) in
      let lst2 = Cons (5, [6; 7; 8]) in
      let lst' =  in
      match List1.map2 lst1 lst2 ~f:(fun x y -> x + y) with
      | Ok res ->
        List1.iter ~f:(fun x -> print_endline (string_of_int x)) res (* Output: 6 9 12 15 *)
      | Error _ -> assert false
    ]}

*)

val map2_exn : 'a t -> 'b t -> f:('a -> 'b -> 'c) -> 'c t
(** [map2_exn l1 l2 ~f] applies the function [f] element-wise to the
    elements of the non-empty lists [l1] and [l2], and returns a new
    non-empty list with the results.

    Return a new non-empty list with the results or raises an
    exception if the [l1] and [l2] have different lengths.

    Example:
    {[
      let lst1 = Cons (1, [2; 3; 4]) in
      let lst2 = Cons (5, [6; 7; 8]) in
      let lst' = map2_exn lst1 lst2 ~f:(fun x y -> x + y) in
      List1.iter (fun x -> print_endline (string_of_int x)) lst' (* Output: 6 9 12 15 *)
    ]}
*)

val filter : 'a t -> f:('a -> bool) -> 'a list
(** [filter l ~f] filters the elements of the non-empty list [l] based
    on the predicate [f] and returns a new list containing only the
    elements that satisfy the predicate.

    Example:
    {[
      let lst = Cons (1, [2; 3; 4; 5; 6]) in
      let filtered = filter lst ~f:(fun x -> x mod 2 = 0) in
      List1.iter (fun x -> print_endline (string_of_int x)) filtered (* Output: 2 4 6 *)
    ]}
*)

val filter_map : 'a t -> f:('a -> 'b option) -> 'b list
(** [filter_map l ~f] applies the function [f] to each element of
    the non-empty list [l] and returns a new list containing the
    transformed elements, while discarding the elements that result in
    [None].

    Example:
    {[
      let lst = Cons (1, [2; 3; 4; 5; 6]) in
      let filtered = filter_map lst ~f:(fun x -> if x mod 2 = 0 then Some (x * 2) else None) in
      List1.iter (fun x -> print_endline (string_of_int x)) filtered (* Output: 4 8 12 *)
    ]}
*)

val iter : 'a t -> f:('a -> unit) -> unit
(** [iter l ~f] applies the function [f] to each element of the
    non-empty list [l]. *)

val fold : 'a t -> init:'c -> f:('c -> 'a -> 'c) -> 'c
(** [fold l ~init ~f] folds over the elements of the non-empty list
    [l] from left to right, using the initial value [init] and the
    function [f]. Returns the result of folding over the elements of
    the list. *)

val fold_right : 'a t -> init:'c -> f:('a -> 'c -> 'c) -> 'c
(** [fold_right l ~init ~f] folds over the elements of the non-empty
    list [l] from right to left, using the initial value [init] and
    the function [f]. Returns the result of folding over the elements
    of the list. *)

val reduce : 'a t -> f:('a -> 'a -> 'a) -> 'a
(** [reduce l ~f] applies the binary function [f] to the elements of
    the non-empty list [l], starting from the left, and returns the
    accumulated result.

    Example:

    {[
      let lst = Cons (1, [2; 3; 4]) in
      let result = reduce lst ~f:(fun acc x -> acc + x) in
      print_endline (string_of_int result) (* Output: 10 *)
    ]}
*)

val to_list : 'a t -> 'a list
(** [to_list l] converts the non-empty list [l] to a standard
    OCaml list. *)

val of_list : 'a list -> 'a t option
(** [of_list l] converts a standard OCaml list [l] to a non-empty
    list. Returns an option containing the non-empty list if [l] is
    not empty, or [None] if [l] is empty. *)

val of_list_exn : 'a list -> 'a t
(** [of_list_exn l] converts a standard OCaml list [l] to a non-empty
    list. Returns the non-empty list if [l] is not empty, or raises an
    exception if [l] is empty. *)

val unzip : ('a * 'b) t -> 'a t * 'b t
(** [unzip l] separates the pairs in the non-empty list [l] into
    two separate non-empty lists.  Return a pair of non-empty lists,
    where the first one contains the first elements of the pairs, and
    the second one contains the second elements of the pairs. *)

val for_all : 'a t -> f:('a -> bool) -> bool
(** [for_all l ~f] checks if all elements of the non-empty list
    [l] satisfy the predicate [f]. Returns [true] if all elements
    satisfy the predicate, [false] otherwise. *)

val exists : 'a t -> f:('a -> bool) -> bool
(** [exists l ~f] checks if at least one element of the non-empty list
    [l] satisfies the predicate [f].  Returns [true] if at least one
    element satisfies the predicate, [false] otherwise. *)

val sort : 'a t -> compare:('a -> 'a -> int) -> 'a t
(** [sort l ~compare] sorts the elements of the non-empty list [l] in
    non-decreasing order based on the comparison function [compare].
    Returns a new non-empty list with the elements sorted in
    non-decreasing order. *)
